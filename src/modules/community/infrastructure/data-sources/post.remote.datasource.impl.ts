import { Injectable } from '@nestjs/common';
import { AppPrismaService } from '../../../../shared/infrastructure/prisma/app-prisma.service';
import {
  PostEntity,
  PostType,
  PostVisibility,
  CommentEntity,
} from '../../domain/entities/community.entity';
import { IPostRemoteDataSource } from './post.remote.datasource.interface';
import {
  PostType as PrismaPostType,
  PostVisibility as PrismaPostVisibility,
  Prisma,
} from '@prisma/client';

type PostWithCounts = Prisma.PostGetPayload<{
  include: {
    _count: {
      select: { comments: true; likes: true };
    };
  };
}>;

function toEntity(row: PostWithCounts): PostEntity {
  return new PostEntity({
    id: row.id,
    userId: row.userId,
    groupId: row.groupId,
    challengeId: row.challengeId,
    content: row.content,
    type: row.type as unknown as PostType,
    mediaUrl: row.mediaUrl,
    visibility: row.visibility as unknown as PostVisibility,
    isAutoGenerated: row.isAutoGenerated,
    challengeTitle: row.challengeTitle,
    taggedUserIds: row.taggedUserIds || [],
    hashtags: row.hashtags || [],
    commentCount: row._count.comments,
    likeCount: row._count.likes,
    createdAt: row.createdAt,
    updatedAt: row.updatedAt,
  });
}

function toCommentEntity(row: Prisma.CommentGetPayload<Record<string, never>>): CommentEntity {
  return new CommentEntity({
    id: row.id,
    postId: row.postId,
    userId: row.userId,
    content: row.content,
    createdAt: row.createdAt,
  });
}

@Injectable()
export class PostRemoteDataSourceImpl implements IPostRemoteDataSource {
  constructor(private prisma: AppPrismaService) {}

  async findById(id: string): Promise<PostEntity | null> {
    const row = await this.prisma.post.findUnique({
      where: { id },
      include: {
        _count: {
          select: { comments: true, likes: true },
        },
      },
    });
    return row ? toEntity(row) : null;
  }

  async findByIds(ids: string[]): Promise<PostEntity[]> {
    if (ids.length === 0) return [];
    const rows = await this.prisma.post.findMany({
      where: { id: { in: ids } },
      include: {
        _count: {
          select: { comments: true, likes: true },
        },
      },
    });
    return rows.map(toEntity);
  }

  async create(post: Partial<PostEntity>): Promise<PostEntity> {
    const row = await this.prisma.post.create({
      data: {
        userId: post.userId!,
        groupId: post.groupId,
        challengeId: post.challengeId,
        content: post.content,
        type: post.type as unknown as PrismaPostType,
        mediaUrl: post.mediaUrl,
        visibility: post.visibility as unknown as PrismaPostVisibility,
        isAutoGenerated: post.isAutoGenerated ?? false,
        challengeTitle: post.challengeTitle,
        taggedUserIds: post.taggedUserIds || [],
        hashtags: post.hashtags || [],
      },
      include: {
        _count: {
          select: { comments: true, likes: true },
        },
      },
    });
    return toEntity(row);
  }

  async update(id: string, post: Partial<PostEntity>): Promise<PostEntity> {
    const row = await this.prisma.post.update({
      where: { id },
      data: {
        content: post.content,
        mediaUrl: post.mediaUrl,
        visibility: post.visibility as unknown as PrismaPostVisibility,
        taggedUserIds: post.taggedUserIds,
        hashtags: post.hashtags,
      },
      include: {
        _count: {
          select: { comments: true, likes: true },
        },
      },
    });
    return toEntity(row);
  }

  async delete(id: string): Promise<void> {
    await this.prisma.post.delete({ where: { id } });
  }

  async list(options: {
    userId?: string;
    groupId?: string;
    limit: number;
    cursor?: string;
    visibility?: string;
  }): Promise<{ items: PostEntity[]; nextCursor?: string }> {
    const take = options.limit + 1;
    const rows = await this.prisma.post.findMany({
      where: {
        userId: options.userId,
        groupId: options.groupId,
        visibility: options.visibility as PrismaPostVisibility,
      },
      take,
      cursor: options.cursor ? { id: options.cursor } : undefined,
      skip: options.cursor ? 1 : 0,
      orderBy: { createdAt: 'desc' },
      include: {
        _count: {
          select: { comments: true, likes: true },
        },
      },
    });

    const hasNextPage = rows.length > options.limit;
    const items = hasNextPage ? rows.slice(0, options.limit) : rows;
    const nextCursor = hasNextPage ? items[items.length - 1].id : undefined;

    return {
      items: items.map(toEntity),
      nextCursor,
    };
  }

  async like(postId: string, userId: string): Promise<void> {
    await this.prisma.like.upsert({
      where: { postId_userId: { postId, userId } },
      create: { postId, userId },
      update: {},
    });
  }

  async unlike(postId: string, userId: string): Promise<void> {
    await this.prisma.like.deleteMany({
      where: { postId, userId },
    });
  }

  async addComment(postId: string, userId: string, content: string): Promise<void> {
    await this.prisma.comment.create({
      data: { postId, userId, content },
    });
  }

  async listComments(
    postId: string,
    limit: number,
    cursor?: string,
  ): Promise<{ items: CommentEntity[]; nextCursor?: string }> {
    const take = limit + 1;
    const rows = await this.prisma.comment.findMany({
      where: { postId },
      take,
      cursor: cursor ? { id: cursor } : undefined,
      skip: cursor ? 1 : 0,
      orderBy: { createdAt: 'desc' },
    });

    const hasNextPage = rows.length > limit;
    const items = hasNextPage ? rows.slice(0, limit) : rows;
    const nextCursor = hasNextPage ? items[items.length - 1].id : undefined;

    return {
      items: items.map(toCommentEntity),
      nextCursor,
    };
  }
}
